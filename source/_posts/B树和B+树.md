---
title: B树和B+树
date: 2020-07-30 11:08:28
tags: ['数据结构', 'MySQL']
category: ['数据结构']
mathjax: true
typora-root-url: ..
---

# 2-3树

概念：**2-3树**是一种**多路查找树**：2和3的意思是2-3树包含两种结点：

<!--more-->

1）**2结点**包含**一个元素**和**两个孩子**（或者**没有孩子**）

​	① 左子树包含结点的元素值小于该结点的元素值，右子树包含结点的元素值大于该结点的元素值

​	② 2结点要么有两个孩子，要么没有孩子，不允许有一个孩子

2）**3结点**包含**一大一小两个元素**和**三个孩子**（或者**没有孩子**）（两个元素按大小顺序排好序）

​	① 左子树包含的结点的元素值小于该结点**较小的**的元素值，右子树包含的结点的元素值大于该结点**较大的**元素值，中间子树包含的结点的元素值介于这两个元素值之间

​	② 3结点要不有三个孩子，要不没有孩子，不允许有一个或两个孩子

3）**2-3树所有叶子结点都在同一层次：**

![2-3树](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/2-3%E6%A0%91.svg)

# 2-3-4树

概念：**2-3-4树**也是一种**多路查找树**：2和3和4的意思就是2-3-4树包含3种结点

1）**2结点**包含**一个元素**和**两个孩子**（或者**没有孩子**）

​	① 左子树包含的结点的元素值小于该结点的元素值，右子树包含的结点的元素值大于该结点的元素值

​	② 2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子

2）**3结点**包含**一大一小两个元素**和**三个孩子**（或者**没有孩子**）

​	① 左子树包含的结点的元素值小于该结点较小的元素值，右子树包含的结点的元素值大于该结点较大的元素值，中间子树包含的结点元素值介于这两个元素之间

​	② 3结点要不有三个孩子，要不就没有孩子，不允许有一个孩子或两个孩子

3）**4结点**包含**小中大三个元素**和四个孩子（或者**没有孩子**）

​	① **最左子树包含的结点的元素值**小于**该结点最小的元素值**，**第二个子树包含的结点的元素值**大于**该结点最小的元素值**小于**该结点中间的元素值**，**第三个子树包含的结点的元素值**大于**该结点中间的元素值**小于**该结点最大的元素值**，**最右子树包含的结点的元素值**大于**该结点最大的元素值**

​	② 4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子

4）2-3-4树所有叶子结点都在同一层次

# B树

## 概念

**B树**也是一种**平衡的多路查找树**，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的**孩子数目**称为**B树的阶**，通常记为m

一棵m阶B树或为**空树**，或为满足如下特性的**m叉树**：

1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字）<-- 两棵子树指针夹着一个关键字

2）若根结点不是终端结点，则至少有两棵子树。（至少一个关键字）

3）除根结点外的所有非叶子结点**至少有⌈m/2⌉棵子树**。（至少含有⌈m/2⌉-1个关键字）<-- 保证B树的平衡性

4）所有非叶子结点的结构如下：

5）所有叶子结点出现在同一层次上，**不带信息**。（就像是折半查找判断树中查找失败的结点）

![B树非叶子结点的结构](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/B%E6%A0%91%E9%9D%9E%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84.png)

其中K<sub>i</sub>(i=1,2,...,n)为结点的**关键字**，且满足**K<sub>1</sub><K<sub>2</sub><K<sub>3</sub><...<K<sub>n</sub>**

其中P<sub>0</sub>(i=0,1,...,n)为指向子树根结点的**指针**，且指针**P<sub>i-1</sub>所指的子树的所有结点的关键字都小于K<sub>i</sub>**

**P<sub>i</sub>所指的子树的所有结点的关键字都小于K<sub>i+1</sub>**

n是结点中关键字的**个数**

## B树的查找操作

**B树是多路查找树**，二叉树排序树是二路查找，B树是多路查找，所以它是二叉排序树的拓展。因此，B树的查找操作和二叉排序树的查找操作非常类似。

**查找过程：**

① 先让待查找关键字key和结点中的关键字进行比较，如果等于其中某个关键字，则查找成功。

② 如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。

Eg：如果Key比第一个关键字K<sub>1</sub>还小，则去P<sub>0</sub>指针所指向的子树中查找，如果比最后一个关键字K<sub>n</sub>还大，则去P<sub>n</sub>指针所指向的子树中查找。

![3阶B树](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/3%E9%98%B6B%E6%A0%91.png)

## B树的插入操作

在二叉排序树中，仅需找到需插入的终端结点的位置。但是，在B树中找到插入的位置后，并不能简单地将其添加到终端结点的位置，因为插入后，可能会导致整棵树不再满足B树中定义的要求。(**可能会打破B树的平衡性等特性**）

给定一组关键字：{20, 30, 50, 52, 60, 68, 70}，给出创建一棵3阶B树的过程。

第①步：由于m=3，所以除了根结点外，非叶子结点至少有**⌈3/2⌉-1=1**个关键字（保证B树的平衡性），最多有**3-1=2**个关键字。所以依次插入20和30两个关键字到结点。

![插入2个关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%8F%92%E5%85%A52%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97.png)

第②步：接下来插入50，如下图，但是由于最多有2个关键字，所以这个结点不满足B树要求，需要**分裂**。

![插入3个关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%8F%92%E5%85%A53%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97.png)

**分裂的方法**：取这个关键字数组中的中间关键字(**⌈n/2⌉**)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子，如下图。

![3个关键字分裂](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/3%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E8%A3%82.png)

第③步：接下来插入52，由于50结点只有一个关键字，所以可以直接插入52，如下图。

![插入4个关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%8F%92%E5%85%A54%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97.png)

第④步：接下来插入60，插入60之后该结点关键字数量不符合要求(>2)，需要进行分裂：

![插入5个关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%8F%92%E5%85%A55%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97.png)



**分裂过程**：取中间关键字（**⌈n/2⌉=⌈3/2⌉=2**）52，由于根结点只含30一个关键字，可以将52和30**合并**到一起。接下来需要处理50和60这两个结点，由于**30<50<52，60>52**，所以50和60可以各自单独作为一个结点。

第⑤步：接下来插入68，由于60结点只有一个关键字，所以可以插入68。

![插入6个关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%8F%92%E5%85%A56%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97.png)

第⑥步：接下来插入70，插入70之后该结点关键字数量又不符合要求，需要分裂：

![插入7个关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%8F%92%E5%85%A57%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97.png)

第⑦步：分裂根结点，类似的，取中间关键字（**⌈n/2⌉=⌈3/2⌉=2**）52作为新的根结点的关键字：

![分裂根结点](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E5%88%86%E8%A3%82%E6%A0%B9%E7%BB%93%E7%82%B9.png)

## B树的删除操作

B树中的删除操作与插入操作类似，但要稍微复杂一些，要使得删除后的结点中的关键字个数 $\geq \lceil m/2 \rceil - 1$，因此将涉及结点的”合并”问题。由于删除的关键字位置不同，可以分为关键字**在终端结点**和**不在终端结点**两种情况。

1）如果删除的关键字在**终端结点**上（最底层的非叶子结点）：

​	① 结点内关键字数量**大于**$\lceil m/2 \rceil -1$，这时删除这个关键字不会破坏B树的定义要求，所以直接删除。

​	② 结点内关键字数量**等于**$\lceil m/2 \rceil -1$，并且其左右兄弟结点中**存在**关键字数量**大于**$\lceil m/2 \rceil -1$的结点，则去兄弟结点中借关键字。

​	③ 结点内关键字数量**等于**$\lceil m/2 \rceil -1$，并且其左右兄弟结点中**不存在**关键字数量**大于**$\lceil m/2 \rceil -1$的结点，则需要进行**结点合并**。

第①种情况：

![第一种情况删除9](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%E5%88%A0%E9%99%A49.png)

第②种情况：

![第二种情况删除2](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%E5%88%A0%E9%99%A42.png)

第③种情况： 

![第三种情况删除16](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E5%88%A0%E9%99%A416.png)

2）如果删除的关键字**不在**终端结点上（**最底层非叶子结点**）：需要先转换成在**终端结点**上，再按照在终端结点上的情况分别考虑对应的方法。

**相邻关键字**：对于不在终端结点上的关键字，它的相邻关键字是其**左子树中值最大的**关键字或者**右子树中值最小的**关键字。

**第一种情况：**存在关键字数量**大于**$\lceil m/2 \rceil - 1$的结点的左子树或右子树，在对应子树上找到关键字的**相邻关键字**，然后将**相邻关键字**替换待删除的关键字。

第①步：找出这个待删除关键字的相邻关键字，比如说下图中10的相邻关键字就是9或者是11，其实就是这个大小序列中该关键字的**直接前驱或者直接后驱关键字**。

![找出相邻关键字](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E6%89%BE%E5%87%BA%E7%9B%B8%E9%82%BB%E5%85%B3%E9%94%AE%E5%AD%97.png)

第②步：将这个待删除的关键字和某个相邻关键字互换（上图中11所在结点只有一个关键字11，删除后不满足关键字数量**大于**$\lceil m/2 \rceil - 1=1$的条件，故选择9进行互换）。

![待删除关键字和某个相邻关键字互换](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E5%BE%85%E5%88%A0%E9%99%A4%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%9F%90%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%92%E6%8D%A2.png)

第③步：此时的待删除关键字所在的结点包含的关键字数量**大于**$\lceil m/2 \rceil - 1=1$，满足待删除结点在终端结点上的一种情况，故直接删除该关键字即可。

![直接删除](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4.png)

**第二种情况：**左右子树的关键字数量**均等于**$\lceil m/2 \rceil - 1=1$，则将这两个左右子树结点**合并**，然后删除待删除的关键字。

![删除关键字不在终端结点上第二种情况](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/%E5%88%A0%E9%99%A4%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%BB%93%E7%82%B9%E4%B8%8A%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5.png)

# B+树

## 概念

B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构。

## m阶的B+树与m阶的B树的**主要差异**

1）在B+树中，具有n个关键字的结点只含有n棵子树，即**每个关键字对应一棵子树**；而在B树中，具有n个关键字的结点含有（n+1）棵子树。

2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是$\lceil m/2 \rceil \leq n \leq m$（根结点：$1 \leq n \leq m$），在B树中，每个结点（非根内部结点）关键字个数n的范围是$\lceil m/2 \rceil -1 \leq n \leq m-1$（根结点：$1 \leq n \leq m-1$）。

3）在B+树中，**叶结点包含信息，所有非叶子结点仅仅起到索引作用**，**非叶结点中的每个索引项**只含有对应子树的**最大关键字**和**指向该子树的指针**，不含有该关键字对应记录的存储地址。**而在B树中每个关键字对应一个记录的存储地址**。

4）在B+树中，**叶结点包含了全部关键字**，即在非叶结点中出现的关键字也会出现在叶结点中，而且叶子结点的指针指向记录；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。

5）在B+树中，有一个指针指向关键字最小的叶子结点，所有叶子结点链接成一个**单链表**。

![B+树](/images/B%E6%A0%91%E5%92%8CB+%E6%A0%91/B+%E6%A0%91.png)

